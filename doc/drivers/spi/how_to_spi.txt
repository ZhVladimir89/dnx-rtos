==============
How To Use SPI
==============

-------------------------------------
1. Meaning of major and minor numbers
-------------------------------------
   Some manufactures enumerate devices starting from 1 instead of 0 (e.g. ST).
   In this case major number starts from 0 and is connected to the first device
   e.g. SPI1.

   a. major number selects SPI peripheral e.g.:
      major = 0 -> SPI0 (or SPI1 if numerated from 1)
      
   b. minor number selects particular device e.g.:
      major = 0 and minor = 0 -> CS0 on SPI0,
      major = 0 and minor = 1 -> CS1 on SPI0,
      major = 1 and minor = 0 -> CS0 on SPI1,
      major = 1 and minor = 2 -> CS2 on SPI1

1.1. Numeration restrictions
   Number of peripherals determines how big major number can be. If there is
   only one SPI peripheral then the major number is always 0.
   Number of devices (minor number) can be theoretically up to 256 or to limits
   of memory capacity.

------------------------
2. Driver initialization
------------------------
   To initialize driver, code as follow should be used:
   
   driver_init("SPI", 0, 0, "/dev/SPI0-0");  // device path can be more user
                                             // friendly e.g. "/dev/LCD"
                                             
   driver_init("SPI", 0, 1, "/dev/SPI0-1");  // next SPI device on SPI0 bus
   ...

-----------------
3. Driver release
-----------------
   To release driver, code as follow should be used:
   
   driver_release("SPI", 0, 0);
   driver_release("SPI", 0, 1);
   ...

-----------------------
4. Driver configuration
-----------------------
   Driver configuration should be done before usage and after initialization.
   The best place to do this is user application. To configure particular SPI
   device the ioctl() function shall be used:
   
   #include <stdio.h>
   #include <stdbool.h>
   #include <sys/ioctl.h>
   
   static const SPI_config_t cfg = {
        .flush_byte  = 0xFF,                             // flush byte
        .clk_divider = SPI_CLK_DIV__4,                   // Peripheral clock / 4
        .mode        = SPI_MODE__0,                      // SPI mode 0
        .msb_first   = true,                             // MSb first
        .CS_port_idx = IOCTL_GPIO_PORT_IDX__CS0,         // port index of CS0
        .CS_pin_idx  = IOCTL_GPIO_PIN_NO__CS0            // pin number of CS0
   };
   
   static const char *dev_path = "/dev/SPI0-0";
   
   FILE *dev = fopen(dev_path, "r+");
   if (dev) {
         if (ioctl(dev, IOCTL_SPI__SET_CONFIGURATION, &cfg) != 0) {
               perror(dev_path);
         }
         
         fclose(dev);
   } else {
         perror(dev_path);
   }
   
   ...
   
4.1. Meaning of Flush Byte
   The Flush Byte is used by the SPI driver to flush frames from SPI device at
   read procedure. The SPI interface is full duplex thus it is not possible to
   write and read data by using fwrite() and fread() interfaces at one time.
   Flush Byte have not any meaning if write procedure is used.
   
   Read: MOSI [ 0xFF ][ 0xFF ][ 0xFF ][ 0xFF ][ 0xFF ] -> Flush bytes
         MISO [DATA-1][DATA-0][DATA-1][DATA-2][DATA-n] -> Data frames read by fread()

-------------
5. Data write
-------------
   Data to a SPI device can be wrote as regular file, but there are some
   restrictions because of SPI specification. Write operation by using fwrite()
   function sends bytes to device but incoming data is not received. Continuous
   write and read operation can be done by using ioctl() function. The fseek()
   function has no impact for SPI communication.
   Example assumptions:
   - SPI device working on MODE 0
   - SCLK frequency is 32 times slower than peripheral clock
   - MSb is send first
   - Flush Byte is 0xFF
   - Device is visible in system as "/dev/SPI0-0"
   
   #include <stdio.h>
   #include <stdbool.h>
   #include <sys/ioctl.h>
   
   static const char *dev_path = "/dev/SPI0-0";
   static const char *blk      = "Data block sent by SPI bus";
   
   static const SPI_config_t cfg = {
        .flush_byte  = 0xFF,                             // flush byte
        .clk_divider = SPI_CLK_DIV__32                   // Peripheral clock / 32
        .mode        = SPI_MODE__0,                      // SPI mode 0
        .msb_first   = true,                             // MSb first
        .CS_port_idx = IOCTL_GPIO_PORT_IDX__CS0,         // port index of CS0
        .CS_pin_idx  = IOCTL_GPIO_PIN_NO__CS0            // pin number of CS0
   };
   
   int_main(spi_ex, STACK_DEPTH_MEDIUM, int argc, char *argv[])
   {
         FILE *dev = fopen(dev_path, "r+");
         
         if (f) {
               // set SPI device configuration
               ioctl(dev, IOCTL_SPI__SET_CONFIGURATION, &cfg);
               
               // write blk
               fwrite(blk, sizeof(char), strlen(blk) + 1, dev);
               
               // close SPI device
               fclose(dev);
               
         } else {
               perror(dev_path);
         }
         
         return 0;
   }

------------
6. Data read
------------
   Data from a SPI device can be read as regular file, but there are some
   restrictions because of SPI specification. Read operation by using fread()
   function sends flush bytes to a device and incoming bytes are received.
   Continuous write and read operation can be done by using ioctl() function.
   The fseek() function has no impact for SPI communication.
   Example assumptions:
   - SPI device working on MODE 0
   - SCLK frequency is 32 times slower than peripheral clock
   - MSb is send first
   - Flush Byte is 0xFF
   - Device is visible in system as "/dev/SPI0-0"
   
   #include <stdio.h>
   #include <stdbool.h>
   #include <dnx/misc.h>
   #include <sys/ioctl.h>
   
   static const char *dev_path = "/dev/SPI0-0";
   
   static const SPI_config_t cfg = {
        .flush_byte  = 0xFF,                             // flush byte
        .clk_divider = SPI_CLK_DIV__32                   // Peripheral clock / 32
        .mode        = SPI_MODE__0,                      // SPI mode 0
        .msb_first   = true,                             // MSb first
        .CS_port_idx = IOCTL_GPIO_PORT_IDX__CS0,         // port index of CS0
        .CS_pin_idx  = IOCTL_GPIO_PIN_NO__CS0            // pin number of CS0
   };
   
   GLOBAL_VARIABLES_SECTION {
         char blk[100];
   };
   
   int_main(spi_ex, STACK_DEPTH_MEDIUM, int argc, char *argv[])
   {
         FILE *dev = fopen(dev_path, "r+");
         
         if (dev) {
               // set SPI device configuration
               ioctl(dev, IOCTL_SPI__SET_CONFIGURATION, &cfg);
               
               // write blk
               fread(global->blk, ARRAY_ITEM_SIZE(global->blk), ARRAY_SIZE(global->blk), dev);
               
               // close SPI device
               fclose(dev);
               
         } else {
               perror(dev_path);
         }
         
         return 0;
   }

---------------------------------------
7. Data read and write at the same time
---------------------------------------
   To read and write bytes from a SPI device can be done by using ioctl()\
   function. In this case special descriptor should be used: SPI_transceive_t.
   By using this function Tx and Rx buffer must have the same sizes.
   Example assumptions:
   - SPI device working on MODE 0
   - SCLK frequency is 32 times slower than peripheral clock
   - MSb is send first
   - Device is visible in system as "/dev/SPI0-0"
   
   #include <stdio.h>
   #include <stdbool.h>
   #include <dnx/misc.h>
   #include <sys/ioctl.h>
   
   static const char *dev_path = "/dev/SPI0-0";

   static const SPI_config_t cfg = {
        .flush_byte  = 0xFF,                             // not used in this example
        .clk_divider = SPI_CLK_DIV__32                   // Peripheral clock / 32
        .mode        = SPI_MODE__0,                      // SPI mode 0
        .msb_first   = true,                             // MSb first
        .CS_port_idx = IOCTL_GPIO_PORT_IDX__CS0,         // port index of CS0
        .CS_pin_idx  = IOCTL_GPIO_PIN_NO__CS0            // pin number of CS0
   };
   
   GLOBAL_VARIABLES_SECTION {
         char tx[5];
         char rx[5];
   };
   
   int_main(spi_ex, STACK_DEPTH_MEDIUM, int argc, char *argv[])
   {        
         FILE *dev = fopen(dev_path, "r+");
         
         if (dev) {
               // set SPI device configuration
               ioctl(dev, IOCTL_SPI__SET_CONFIGURATION, &cfg);
               
               // prepare data to send
               global->tx[0] = 0x10;
               global->tx[1] = 0x20;
               global->tx[2] = 0x30;
               global->tx[3] = 0x40;
               global->tx[4] = 0x50;
               
               // send and recive prepared block
               SPI_transceive_t t = {
                     .tx_buffer = global->tx,      // bytes to send
                     .rx_buffer = global->rx,      // buffer to received data
                     .count     = ARRAY_SIZE(tx)   // buffer size
               };
              
               ioctl(dev, IOCTL_SPI__TRANSCEIVE, &t);
               
               // close SPI device
               fclose(dev);
               
         } else {
               perror(dev_path);
         }
         
         return 0;
   }

-------------
8. References
-------------
   - SPI driver, src/system/drivers/spi
